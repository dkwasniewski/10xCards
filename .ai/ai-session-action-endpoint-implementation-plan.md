# API Endpoint Implementation Plan: POST `/ai-sessions/{sessionId}/candidates/actions`

## 1. Endpoint Overview
Bulk–process candidate flashcards generated by an AI generation session. The endpoint enables the client to **accept**, **edit**, or **reject** multiple candidates in a single request, updating both the `flashcards` and `ai_generation_sessions` tables accordingly and returning a summary of the actions performed.

## 2. Request Details
- **HTTP Method**: POST
- **URL Pattern**: `/api/ai-sessions/{sessionId}/candidates/actions`
  - `sessionId` – UUID v4 of an existing AI generation session belonging to the authenticated user (path param, **required**)

### Parameters
| Location | Name | Type | Required | Description |
|----------|------|------|----------|-------------|
| Path | `sessionId` | string (UUID) | ✅ | Target generation session |

### Request Body (JSON)
```json
{
  "actions": [
    {
      "candidate_id": "uuid",
      "action": "accept" | "edit" | "reject",
      "edited_front": "?string",
      "edited_back": "?string"
    }
  ]
}
```

| Field | Type | Required | Notes |
|-------|------|----------|-------|
| `actions` | array | ✅ | 1-100 items to prevent abuse |
| `candidate_id` | string (UUID) | ✅ | Must belong to `sessionId` & current user |
| `action` | enum | ✅ | One of `accept \| edit \| reject` |
| `edited_front` | string | ▫️ | Required when `action === \"edit\"`; max 200 chars |
| `edited_back` | string | ▫️ | Required when `action === \"edit\"`; max 500 chars |

## 3. Used Types
*From `src/types.ts`*
- `CandidateActionCommand`
- `CandidateActionResponseDto`
- (Indirect) `FlashcardDto`, `Tables<\"flashcards\">`

## 4. Response Details
**Status Codes & Bodies**
| Code | When | Body |
|------|------|------|
| 200 OK | All actions processed | `CandidateActionResponseDto` → `{ accepted: string[]; edited: string[]; rejected: string[] }` |
| 400 Bad Request | Validation / malformed body | `{ error: "message" }` |
| 401 Unauthorized | No valid session cookie / token | `{ error: "unauthorized" }` |
| 404 Not Found | `sessionId` or any `candidate_id` not found / not owned by user | `{ error: "not_found" }` |
| 500 Internal Server Error | Unhandled exceptions | `{ error: "internal" }` |

## 5. Data Flow
1. **Astro API Route** `src/pages/api/ai-sessions/[sessionId]/candidates/actions.ts` (new file)
2. Retrieve `supabase` from `Astro.locals` (middleware already injects auth session).
3. **Validation** using Zod schema → convert to `CandidateActionCommand`.
4. **Service Call** `aiSessionsService.processCandidateActions(supabase, sessionId, command, userId)`.
5. **Service Logic** (new or extended in `src/lib/services/ai-sessions.service.ts`):
   - BEGIN TRANSACTION
   - Verify `ai_generation_sessions.id = sessionId AND user_id = userId` (404 if not).
   - Fetch all `flashcards` rows where `id IN candidate_ids` and `ai_session_id = sessionId`.
     - Ensure they are still in *candidate* state (not accepted/rejected yet).
   - For each action:
     - **accept**: `UPDATE flashcards SET source = 'ai', status = 'accepted', updated_at = now()`; increment `accepted_unedited_count`.
     - **edit**: same as accept *plus* `front = edited_front`, `back = edited_back`; increment `accepted_edited_count`.
     - **reject**: `UPDATE flashcards SET status = 'rejected'` OR `DELETE` (decision: prefer status flag for audit).
   - Update counters on `ai_generation_sessions` in a single statement.
   - COMMIT
6. Return summary arrays grouped by action.
7. **Event Logging** (`eventLogService.create`): store one event per action or a bulk event summarising counts.

## 6. Security Considerations
- **Authentication**: Require valid Supabase session (middleware handles, else 401).
- **Authorization**: Verify `sessionId` & `candidate_id` rows belong to `user_id`.
- **Input Sanitisation**: Zod length checks prevent oversized strings; strings stored in DB are parametrised → prevents SQL injection.
- **Rate Limiting**: Global middleware / Supabase Edge limits to e.g. 10 req/s per IP.
- **Replay Protection**: Reject already-processed candidates (idempotency at record level).

## 7. Error Handling
| Scenario | Response | Notes |
|----------|----------|-------|
| Body fails Zod validation | 400 | Include details array |
| Missing `edited_front/back` when `action === edit` | 400 | Validation rule |
| Unknown `action` value | 400 | Enum check |
| Session not found / belongs to other user | 404 | |
| Candidate not found / not in session | 404 | List offending ids in error message |
| Database error | 500 | Log via `eventLogService` |

## 8. Performance Considerations
- **Batch Queries**: Use `UPDATE ... WHERE id IN (...)` for each action type to minimise network round-trips.
- **Index Usage**: Ensure index on `flashcards(ai_session_id, id)` and counts columns already defined (`add_flashcards_user_created_index.sql`).
- **Payload Size**: Limit `actions.length` to 100 to prevent large JSON bodies.

## 9. Implementation Steps
1. **Design Zod Schema** `flashcardCandidateActionsSchema` in `src/lib/schemas/flashcards.schemas.ts`.
2. **Extend Service** `ai-sessions.service.ts`:
   - Add `processCandidateActions` with transaction logic described above.
3. **Create API Route**
   - Path: `src/pages/api/ai-sessions/[sessionId]/candidates/actions.ts`.
   - `export const prerender = false;` per rules.
   - Parse `sessionId` from `Astro.params`.
   - Validate body ➜ command.
   - Call service ➜ result ➜ `return new Response(JSON.stringify(result), { status: 200 });`.
4. **Update DB Constraints** (if not present): add `status` enum or boolean flags; ensure counters are nullable + default 0.
5. **Add Event Logging** to `event-log.service.ts`.
6. **Write Unit Tests** in `/tests/api/ai-sessions.spec.ts` covering:
   - Happy path (accept, edit, reject mix)
   - Unauthorized user
   - Validation errors
   - Already processed candidates → 400
7. **Update Documentation** `.ai/api-plan.md` and OpenAPI spec if maintained.
8. **Run Lint & CI** to ensure code quality.
9. **Deploy** to staging → verify with real front-end call from MyFlashcards view.

