import type { APIRoute } from "astro";
import type { CandidateActionCommand, CandidateActionResponseDto } from "../../../../../types";
import { candidateActionsSchema } from "../../../../../lib/schemas/flashcards.schemas";
import { sessionIdSchema } from "../../../../../lib/schemas/ai-sessions.schemas";
import { processCandidateActions } from "../../../../../lib/services/ai-sessions.service";
import { logEvent } from "../../../../../lib/services/event-log.service";

export const prerender = false;

/**
 * Helper function to create standardized error responses.
 */
function errorResponse(status: number, error: string, details?: Record<string, unknown>) {
  return new Response(JSON.stringify({ error, ...details }), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

/**
 * POST /api/ai-sessions/{sessionId}/candidates/actions
 *
 * Bulk-process candidate flashcards generated by an AI generation session.
 * Enables accepting, editing, or rejecting multiple candidates in a single request.
 *
 * Flow:
 * 1. Validate sessionId path parameter
 * 2. Parse and validate request body
 * 3. Verify session ownership
 * 4. Process actions (accept/edit/reject) in batches
 * 5. Update session counters
 * 6. Log event for analytics
 * 7. Return summary of processed actions
 */
export const POST: APIRoute = async ({ request, params, locals }) => {
  const supabase = locals.supabase;
  if (!supabase) {
    return errorResponse(500, "Internal server error", {
      message: "Supabase client unavailable",
    });
  }

  // Get authenticated user
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();
  if (authError || !user) {
    return errorResponse(401, "Unauthorized");
  }
  const userId = user.id;

  // 1. Validate sessionId path parameter
  const sessionIdResult = sessionIdSchema.safeParse(params.sessionId);
  if (!sessionIdResult.success) {
    return errorResponse(400, "Invalid sessionId", {
      details: sessionIdResult.error.errors,
    });
  }
  const sessionId = sessionIdResult.data;

  // 2. Parse and Validate Request Body
  let body: unknown;
  try {
    body = await request.json();
  } catch {
    return errorResponse(400, "Invalid JSON", {
      message: "Request body must be valid JSON.",
    });
  }

  const parseResult = candidateActionsSchema.safeParse(body);
  if (!parseResult.success) {
    return errorResponse(400, "Validation failed", {
      details: parseResult.error.errors,
    });
  }

  const command = parseResult.data as CandidateActionCommand;

  // 3. Process candidate actions
  let result: CandidateActionResponseDto;
  try {
    result = await processCandidateActions(supabase, sessionId, command, userId);
  } catch (error) {
    // Handle specific error types
    if (error instanceof Error && error.name === "NotFoundError") {
      return errorResponse(404, "Not found", {
        message: error.message,
      });
    }

    // Log failure event
    await logEvent(supabase, {
      userId,
      eventType: "candidate_actions_failed",
      eventSource: "ai",
      aiSessionId: sessionId,
    });

    return errorResponse(500, "Internal server error", {
      message: "Failed to process candidate actions. Please try again.",
    });
  }

  // 4. Log success events with detailed metrics
  // Log individual events for each action type to support analytics
  if (result.accepted.length > 0) {
    await logEvent(supabase, {
      userId,
      eventType: `candidates_accepted_unedited:${result.accepted.length}`,
      eventSource: "ai",
      aiSessionId: sessionId,
    });
  }

  if (result.edited.length > 0) {
    await logEvent(supabase, {
      userId,
      eventType: `candidates_accepted_edited:${result.edited.length}`,
      eventSource: "ai",
      aiSessionId: sessionId,
    });
  }

  if (result.rejected.length > 0) {
    await logEvent(supabase, {
      userId,
      eventType: `candidates_rejected:${result.rejected.length}`,
      eventSource: "ai",
      aiSessionId: sessionId,
    });
  }

  // Log overall summary event
  await logEvent(supabase, {
    userId,
    eventType: `candidate_actions_processed:total=${command.actions.length}`,
    eventSource: "ai",
    aiSessionId: sessionId,
  });

  // 5. Return summary response
  return new Response(JSON.stringify(result), {
    status: 200,
    headers: { "Content-Type": "application/json" },
  });
};
